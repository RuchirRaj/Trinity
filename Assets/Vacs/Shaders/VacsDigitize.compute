#pragma kernel Update

#include "Common.hlsl"
#include "SimplexNoise3D.hlsl"

StructuredBuffer<float4> PositionSource;
StructuredBuffer<float4> NormalSource;
StructuredBuffer<float4> TangentSource;

RWBuffer<float4> PositionOut;
RWBuffer<float4> NormalOut;
RWBuffer<float4> TangentOut;

CBUFFER_START(Params)
    uint TriangleCount;
    float Time;
CBUFFER_END

[numthreads(256, 1, 1)]
void Update(uint id : SV_DispatchThreadID)
{
    if (id * 2 >= TriangleCount) return;

    // First triangle
    uint i1 = id * 2;
    uint i2 = id * 2 + TriangleCount;
    uint i3 = id * 2 + TriangleCount * 2;

    // Second triangle (consecutive)
    uint i4 = i1 + 1;
    uint i5 = i2 + 1;
    uint i6 = i3 + 1;

    // Vertex positions
    float3 p1 = PositionSource[i1].xyz;
    float3 p2 = PositionSource[i2].xyz;
    float3 p3 = PositionSource[i3].xyz;
    float3 p4 = PositionSource[i4].xyz;
    float3 p5 = PositionSource[i5].xyz;
    float3 p6 = PositionSource[i6].xyz;

    // Centroids
    float3 c123 = (p1 + p2 + p3) / 3;
    float3 c456 = (p4 + p5 + p6) / 3;
    float3 call = (c123 + c456) / 2;

    // Noise field
    float3 p_n = call * 1.2 + float3(0, Time / 2, Time / 4);
    float param = saturate(snoise(p_n).w + 0.25);

    // Position on the unit circle and its tangent
    float3 p_cir = float3(normalize(call.xz), call.y).xzy;
    float3 p_tan = -p_cir.zyx * float3(-1, 0, 1);

    // Random distribution
    p_cir.xz *= Random(id) * 0.4 + 0.1;

    // Quad size
    float size = sin(Random(id + 100000) * PI * 2 + Time * 3) * 0.1 + 0.1;

    // Edge vectors
    float3 edge_u = float3(0, size, 0);
    float3 edge_v = p_tan * size;

    // Modified vertex positions
    float3 p1m = p_cir;
    float3 p2m = p_cir + edge_u;
    float3 p3m = p_cir + edge_v;
    float3 p4m = p_cir + edge_u + edge_v;

    // Interpolation
    p1 = lerp(p1, p1m, param);
    p2 = lerp(p2, p2m, param);
    p3 = lerp(p3, p3m, param);
    p4 = lerp(p4, p2m, param);
    p5 = lerp(p5, p4m, param);
    p6 = lerp(p6, p3m, param);

    // Modified normal vectors
    float flat = saturate(param * 10);
    float4 n123 = float4(normalize(cross(p2 - p1, p3 - p1)), 1);
    float4 n456 = float4(normalize(cross(p5 - p4, p6 - p4)), 1);

    // Output
    PositionOut[i1] = float4(p1, 0);
    PositionOut[i2] = float4(p2, 0);
    PositionOut[i3] = float4(p3, 0);
    PositionOut[i4] = float4(p4, 0);
    PositionOut[i5] = float4(p5, 0);
    PositionOut[i6] = float4(p6, 0);

    NormalOut[i1] = lerp(NormalSource[i1], n123, flat);
    NormalOut[i2] = lerp(NormalSource[i2], n123, flat);
    NormalOut[i3] = lerp(NormalSource[i3], n123, flat);
    NormalOut[i4] = lerp(NormalSource[i4], n456, flat);
    NormalOut[i5] = lerp(NormalSource[i5], n456, flat);
    NormalOut[i6] = lerp(NormalSource[i6], n456, flat);

    TangentOut[i1] = TangentSource[i1];
    TangentOut[i2] = TangentSource[i2];
    TangentOut[i3] = TangentSource[i3];
    TangentOut[i4] = TangentSource[i4];
    TangentOut[i5] = TangentSource[i5];
    TangentOut[i6] = TangentSource[i6];
}
